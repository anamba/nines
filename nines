#!/usr/bin/env ruby

require 'rubygems'
require 'yaml'
require 'dnsruby'
require 'net/ping'

@@config = YAML.load(File.read('config.yml'))
@@logfile = @@config['logfile'] || 'nines.log'
@@pidfile = @@config['pidfile'] || 'nines.pid'
@@debug = @@config['debug']
@@user_agent = "nines/1.0"

@@continue = true
trap("INT") { @@continue = false ; puts "Caught SIGINT, will exit after current checks complete or time out." }
trap("TERM") { @@continue = false ; puts "Caught SIGTERM, will exit after current checks complete or time out." }

arg = ARGV.shift
case arg
when 'stop'
  begin
    pid = File.read(@@pidfile).to_i
    Process.kill "INT", pid
  rescue Exception => e
    puts "Could not stop background process: #{e}"
    exit 1
  end
  exit 0
end


# do some config checks
begin
  File.open(@@logfile, 'a') { }
rescue Exception => e
  puts "Couldn't open #{@@logfile} for logging (error: #{e})"
end
begin
  File.open(@@pidfile, 'a') { }
rescue Exception => e
  puts "Couldn't write pid to #{@@pidfile} (error: #{e})"
end

@@config['hosts'].each do |host, options|
  # make sure each has a valid hostname at least
  unless options['hostname'] && Dnsruby::Resolv.getaddress(options['hostname'])
    puts "Error: host #{host} has invalid hostname '#{options['hostname']}'"
    exit 1
  end
end


# then fork and detach
if pid = fork
  File.open(@@pidfile, 'w') { |f| f.print pid }
  puts "Background process started with pid #{pid} (end it using `#{$0} stop`)"
  puts "Debug mode enabled, background process will log to STDOUT and exit after running each check once." if @@debug
  exit 0
end

logger = @@debug ? STDOUT : File.open(@@logfile, 'a')
logger.sync = 1
logger.puts "[#{Time.now}] - nines starting"

# iterate through config
threads = []
@@config['hosts'].each do |host, options|
  logger.puts "Starting up checks for #{host}"
  hostname = options['hostname']
  address = Dnsruby::Resolv.getaddress(options['hostname'])
  
  options.each do |name, check|
    case name
    when /http-check/
      threads << Thread.new(Thread.current) { |parent|
        begin
          timeout = check['timeout_sec'] || 5
          port = check['port'] || 80
          interval = check['interval_sec'] || 5
          uri = check['uri'] || "http://#{hostname}:#{port}/"
          
          while @@continue do
            pinger = Net::Ping::HTTP.new(uri, port, timeout)
            pinger.user_agent = @@user_agent
            if pinger.ping?
              logger.puts "[#{host}] Check passed: #{uri} (#{address}), timeout #{timeout}#{pinger.warning ? " [warning: #{pinger.warning}]" : ''}"
            else
              logger.puts "[#{host}] Check FAILED: #{uri} (#{address}), timeout #{timeout} [reason: #{pinger.exception}]"
              # do some notification stuff
            end
            
            # TODO: log result
            
            @@continue = false if @@debug
            
            wait = interval.to_f - (pinger.duration || 0)
            while wait > 0 do
              break unless @@continue
              sleep [1, wait].min
              wait -= 1
            end
          end
        rescue Exception => e
          parent.raise e
        end
      }
    
    when /ping-check/
      threads << Thread.new(Thread.current) { |parent|
        timeout = check['timeout_sec'] || 5
        port = check['port']
        interval = check['interval_sec'] || 5
        protocol = check['protocol'].downcase || 'icmp'
        
        while @@continue do
          pinger = case protocol
            when 'tcp'  then Net::Ping::TCP.new(hostname, nil, timeout)
            when 'udp'  then Net::Ping::UDP.new(hostname, nil, timeout)
            when 'icmp'
              if Process::UID == 0
                Net::Ping::ICMP.new(hostname, nil, timeout)
              else
                Net::Ping::External.new(hostname, nil, timeout)
              end
            else "invalid ping protocol #{protocol}"
          end
          
          if pinger.ping?
            logger.puts "[#{host}] Check passed: #{protocol == 'icmp' ? 'icmp' : "#{protocol}/#{port}"} ping on #{hostname} (#{address}), timeout #{timeout}"
          else
            logger.puts "[#{host}] Check FAILED: #{port ? "#{protocol}/#{port}" : protocol} ping on #{hostname} (#{address}), timeout #{timeout}"
            # do some notification stuff
          end
          
          # TODO: log result
          
          @@continue = false if @@debug
          
          wait = interval.to_f - (pinger.duration || 0)
          while wait > 0 do
            break unless @@continue
            sleep [1, wait].min
            wait -= 1
          end
        end
      }
    end
  end
end

threads.each { |t| t.join if t.alive? }

logger.puts "[#{Time.now}] - nines finished"
logger.close unless @@debug
puts "Background process finished"
